# Модуль "Учет финансов" ТигрБанка.
Этот модуль будет включать инструменты, упрощающие управление личными финансами: анализ доходов и расходов, планирование бюджета, рекомендация выгодных предложений. Такой подход поможет пользователям более осознанно распоряжаться средствами и достигать своих финансовых целей!

## Предметная область 
Программа моделирует часть функциональности личного кабинета клиента банка, отвечающую за хранение, обновление и предоставление информации о счетах, операциях и их категориях; а также предоставляет возможность проводить аналитику по финансовым операциям и сохранять её результаты в файл указанного формата для предоставления по месту требования. Для демонстрации возможностей программного модуля используется реализация конкретного пользовательского сценария в консольном приложении. 

## Архитектура программного модуля 
Система включает в себя:
- набор доменных сущностей, лежащих в основании модуля 
- репозитории - абстракции, имплементирующие CRUD-операции и предназначенные для хранения сущностей 
- набор сервисов, которые реализуют некоторую бизнес-логику
- консольное приложение, которое запускает пользовательский сценарий работы.

**Структура проекта** выглядит следующим образом: 
```text
src/
    model/                                          # Слой доменных сущностей
        CategoryType.java                           # тип категории (INCOME/EXPENSE)    
        Category.java                               # категория операции
        OperationType.java                          # тип операции (INCOME/EXPENSE)
        Operation.java                              # операция 
        BankAccount.java                            # банковский счет клиента     
    
    repository/                                     # Слой доступа к данным                   
        IBankAccountRepository.java                 # интерфейс репозитория банковского аккаунта
        ICategoryRepository.java                    # интерфейс репозитория категорий 
        IOperationRepository.java                   # интерфейс репозитория операций
        InMemoryBankAccountRepository.java          # репозиторий, который хранит счета в оперативной памяти
        InMemoryCategoryRepository.java             # репозиторий, который хранит операции в оперативной памяти 
        InMemoryOperationRepository.java            # репозиторий, который хранит все операции в оперативной памяти 

    service/                                        # Слой бизнес-логики
        IAnalyticsService.java                      # интерфейс сервиса аналитики
        IBalanceRecalculator.java                   # интерфейс с врвиса, для пересчета баланса
        IDataService.java                           # интерфейс сервиса для экспорта и импорта данных в файлы 
        IOperationService.java                      # интерфейс сервиса по работе с операциями  
        AnalyticsService.java                       # сервис аналитики, имплементирующий соответствующий интерфейс
        BalanceRecalculator.java                    # севрвис пересчета баланса, имплементирующий соответствующий интерефейс
        JsonDataService.java                        # сервис импорта/экспорта в файлы 
        OperationService.java                       # сервис по работе с операциями 

    dto/                                            # Слой вспомогательных объектов для передачи между сервисами (data transfer object) 
        mixin/                                      # mixins нужны для подмешивания аннотаций, чтобы не загрязнять доменные классы зависимостями при работе с Jacson(сериализация/десериализация)
            BankAccountMixin.java
            CategoryMixin.java
            OperationMixin.java
        FinanceData.java
    
    console/                                        # Консольное приложение 
        FinanceApplication.java                     # точка входа 
        FinanceRunner.java                          # вызов пользовательского сценария 
test/
        BankAccountTest.java                        # тесты для банковского счета
        CategoryTest.java                           # тесты для категорий 
        OpeartionTest.java                          # тесты для операций
```

### Доменный слой 
#### Класс 'Category' 
Моделирует сущность категории операции (например, 'Здоровье', 'Зарплата', 'Кэшбек' и любые другие, которые будет поддерживать банк). Имеет свой идентификационный номер(id), название(name) и тип(type). Имеет геттеры, методы валидации собственных свойств, а также метод переименования категории.
#### Класс 'Operation' 
Моделирует сущность банковской операции, которой может быть присвоена некоторая категория (необязательно). Имеет свой идентификационный номер(id), тип(type), привязку к счету(accountId), сумму(amount), дату(date), описание(descroption), привязку к категории(categoryId). Имеет геттеры, методы валидации, отвязки/привязки категории. 
Каждая категория и каждая операция обязательно содреж. Сейчас все репозитории доменных сущностей, которые имплементируют соответствующий интерфейс, представляют собой работу с хранилищем, расположенного в оперативной памяти, а именно некоторые Map. Мы легком сможем подменить реализацию на репозиторий, хранилищем которого является некоторая база данных. При этом наш клиентский код, в данном случае код сервиса, ничего об этом не узнает. NSE'. Технически для этого созданы отдельные перечисления: 'CategoryType' и 'OperationType'. Нужно это для того, чтобы валидировать непротиворечивость категорий и операций. Например, теоретически могло бы быть такое: тип операции - расход, а ей присуща категория 'Зарплата', что сементически неверно.   
#### Класс 'BankAccount' 
Моделирует сущность банковского счета. Имеет идентификационный номер(id), имя(name), а также текущий баланс(balance). Имеет методы пополнения и снятие баланса, а также методы валиции свойств. 

*Ключевой особенностью* каждой доменной сущности является присвоение каждой из них при создании некоторого глобально уникального номера (UUID), у которого вероятность коллизий крайне мала. С одной стороны это большой плюс: сущности могут быть созданы модулем изолированно без необходимости, например, лезть в репозиторий, чтобы забрать последний зарегистрированный последовательный id. С другой стороны, вся ответственность за ограничение ссылочной целостности(непротиворечивость данных) ложится на бизнес-слой нашего модуля. 

Доменные сущности имеют методы валидации собственных свойств(например, имя не может быть пустым и его длина не должна быть больше 100 символов - ограничение БД, или же баланс не может быть отрицательным - у нас только дебетовые счета). Так же, например, у нас есть ограничение на дату проведения операции - она не может быть в будущем. Проверка осуществляется одним из методов валидации соответствующего доменного класса.   

### Слой доступа к данным 
Каждая доменная сущность имеет свой репозиторий для хранения, в интерфейсе которых определены специализированные методы, представляющие собой CRUD-операции. Это отражено в названиях соответствюущих интерфейсов и классов. 

### Слой бизнес логики 
Сервисы представляют собой абстракции для организации и агрегации специализированных бизнес-процессов. Они инкапсулируют правила предметной области, а следовательно, координируют взаимодействие между репозиториями и доменными сущностями, и, возможно, более мелкими сервисами. 
#### Класс 'BalanceRecalculator'
Моделирует бизнес-процесс по перерасчету баланса, имплементирует интерфейс 'IBalanceRecalculator'. В качестве зависимости принимает в своей конструктор ссылки на объекты классов, имплементирующих интерфейс репозиториев операций и банковских счетов. В классе реализован метод, который по указанному счёту пересчитывает баланс по всем операциям. При этом логика взаимодействия с репозиториями ложится на его плечи.  
#### Класс 'AnalyticsService' 
Моделирует бизнес-процесс по проведению и предоставлению аналитики, иммплементирует интрефейс 'IAnalyticsService'. В качестве зависимости в своей конструктор принимает ссылки на объекты классов, имплеменитрующих интерфейс репозиториев операций и категорий. Аналогично на его плечи ложиться логика по взаимодействию с репозиториями для извлечения необходимых данных и проведению аналитических расчетов. 
#### Класс 'JsonDataService'
Моделирует бизнес-процесс по экспорту/импорту данных, имплементирует интерфейс 'IDataService'. Записывет все данные из описанных репозиториев категорий, операций и банковских счетов в JSON, а также наоборот заполняет репозиторий из JSON файла. 
#### Класс 'OperationDataService'
Моделирует бизнес-процесс, связанный с работой с операциями. В качестве зависимости данному классу передаются все три репозитория, а также класс пересчета баланса банковских счетов. Цикл добавления/удаления операций становится более полноценным: если добавляем операцию, то и баланс надо пересчитать, аналогично для удаления. Таким образом, данный сервис имеет более высокий уровень абстракции своего интерефейса, чем тот же репозиторий.  
#### Использование DI-контейнера
Поскольку зависимостей у сервиса может быть много, то внедрять их вручную не очень удобно. Поэтому в данном приложении для автоматизации внедрения всех зависимостей используется DI-контейнер, предоставляемый фреймворком Spring. Это избавляет нас от ручного внедрения зависимостей и написания собственного DI-контейнера. 

### Тесты 
Модульное тестирование проведено только для проверки поведения доменных сущностей, поскольку они не содержат зависимостей и наиболее просты для написания тестов.Тестирование сфокусировано на валидации бизнес-инвариантов на уровне объектов.

### Пользовательский сценарий работы
В методе 'run' класса 'FinanceRunner' приведен пользовательский сценарий работы. Приведем его описание: 
1. Создается основной счет.
2. Создаются 3 категории: 'Зарплата', 'Кафе', 'Здоровье'.
3. Создаются и добавляются в 'OperationService' 4 операции. 
4. Проверяется баланс, который пересчитывался после добавления каждой операции.
5. Смотрим аналитику за неделю с помощью объекта класса 'AnalyticsService', а именно чистый доход и группировку по категориям для расходов.
6. Сохраняем аналитику в JSON. 
7. Экспортируем все данные по всем репозиториям в JSON. 
8. Чистим все репозитории. 
9. Импортируем JSON файл и выводим резульутат для проверки. 

## Требование соблюдения SOLID принципов 
При проектировани модуля строго соблюдены все 5 принципов. 
### SRP (Single Resposibility Principle)
Поскольку классы доменных сущностей моделирует эти самые сущности реального мира, то принцип единственной отвественности соблюден. Модель доменной сущности предназначена отображать реальную сущность, то есть она хранит только свои свойства и не содержит никакого лишнего поведения, не присущего реальному объекту.
Аналогично можно сказать в целом и про репозитории с сервисами. Каждый занимается строго своей задачей: репозиторий предоставляет интерфейс для сохранения, обновления и т.п. данных соответсвующих доменных объектов, сервисы - моделируют возложенную на них бизнес-логику. Таким образом, мы не имеем никаих "божественных" классов. 
### SLP (Liskov Substitution Principle)
В данном модуле нет явной демонстрации данного принципа - никакие объекты не связаны наследием. Раз нет объектов, связанных через наследство, то и нарушать принцип подстановки некому.
### ISP (Interface Segregation Principle) 
Все имеющиеся интерфейсы достаточно тонкие: 'IOperationRepository', 'IOperationService' и т.д. Содержат только те операции, которые действительно нужны в этом интерфейсе и ничего лишнего. Для репозиториев - это операции сохранения, обновления, выдачи данных(возможно, специализированные методы выдачи даннных, например, выдача данных за некоторый период метод 'findByPeriod' в 'IOperationRepository'). Для сервисов - присущие им специальные методы.
### DIP (Dependency Inversion Principle)
Достаточно яркий пример следования данному принципу видно на примере сервиса 'AnalyticsService'. Данный сервис не зависит от низкоуровенвых абстракций, таких как репозитории операций и категорий - он зависит от интерфейсов 'ICategoryRepository' и 'IOperationRepository'. В целом, это касается всех сервисов. При этом каждый сервис имплементирует некоторый интерфейс - заготовка на будущее, если вдруг появится какой-то класс с еще более высоким уровенем абстракции (например, класс пользовательского сценария). На самом деле это уже находит свое применение, поскольку класс 'FinanceRunner' (класс конкретного сценария) уже зависит от этих интрефейсов. 
### OCP (Open-Closed Principle)
Достаточно яркий пример следования данному принципу это использование интерфейсов репозиториев в работе сервисов. Сейчас все репозитории доменных сущностей, которые имплементируют соответствующий интерфейс, представляют собой работу с хранилищем, расположенного в оперативной памяти, а именно некоторые Map. Мы легком сможем подменить реализацию на репозиторий, хранилищем которого является некоторая база данных. При этом наш клиентский код, в данном случае код сервиса, ничего об этом не узнает. То же самое касается и экспорта файла в другой формат данных. Выберем другой формат, сделаем другую имплеменатцию интерфейса, клиентский код ничего не узнает. 
Захотели новые отчёты - изменили имплементацию 'IAnalyticsService'. 
Помимо этого добавления новых категорий, очевидно, не заставляет переписывать код. Все категории будут учтены, например, в сервисе аналитики. 

## Проблемы при расширении 
- Проблема мультивалютности. Сейчас работаем только с одной валютой. Храним баланс как BigDecimal без привязки к валюте. 
- Невозможно добавить уведомления, логирование или интеграции без изменения бизнес-логики сервисов.
- Отсутствие механизма транзакций. При переводе со счета на счет деньги могут быть сняты, а при сбое не успеют зачислиться. Получаем потерю данных. Необходимо менять бизнес-логику.

## Почему данный подход улучшил качество дизайна 
1. Легко подменять реализацию репозиториев (если меняем тип хранилища, СУБД и пр.)
2. Легко можем подменять реализацию сервиса без изменения уже существующих классов. Захотим работу сервиса с логированием или кэшированием? Сделаем новую имплементацию. Клиентский код никак при этом затронут не будет.
3. Можем мокать сервисы, репозитории, сценарии (если будут). Для тестирования не будет нужен реальный объект. 
4. Нет неявных зависимостей. Все зависимости передаются через конструктор класса. Получаем предсказуемость, легкочитаемость.
5. Доменные сущности без зависимостей. Следовательно, можно использовать в другом проекте и при использовании другого фреймворка.   

## Cсылка на скринкаст
https://drive.google.com/file/d/1d47c7HOny9tBMcE95gLOYRI516yj04u9/view?usp=sharing